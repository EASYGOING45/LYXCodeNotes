# 操作系统归档-Part1

## 进程和线程的区别

基本概念

​	进程是运行时程序的封装，是系统资源调度和分配的基本单位，实现了操作系统的并发性

​	线程是进程的子任务，是CPU调度的基本单位，用来保证程序的实时性，实现了进程内部的并发性。

​	线程是操作系统所识别的执行和调度的最小单位，每个线程占用它自己的虚拟处理器：他自己的寄存器库、指令计数器和处理器状态。

​	每个线程执行不同的任务，但共享相同的地址空间（即相同的动态内存、映射文件、目标代码等）、打开的文件队列和其他内核资源。

区别：

1. 一个线程只能属于一个进程，一个进程可以有多个线程，线程的存在取决于进程
2. 进程在执行过程中有一个独立的内存单元，多个线程共享进程的内存。将资源分配给一个进程，同一进程的所有线程共享该进程的所有资源。同一个进程中的多个线程共享代码段（代码和常量）、数据段（全局变量和静态变量）和扩展段（堆存储），但是每个线程都有自己的堆栈段，称为运行时堆栈，它包含所有的局部变量和临时变量。
3. 进程是资源分配的最小单位，线程是CPU调度的最小单位
4. 开销：当一个进程被创建或撤销时，系统为它分配或回收资源，例如内存空间和IO设备，因此，操作系统产生的开销比创建或撤销线程产生的开销大得多。
   1. 类似的，进程切换包括当前进程的整个CPU环境，并设置新调度进程的CPU环境。
   2. 然而，线程切换只保存和设置少量寄存器的内容，不涉及内存管理操作，进程切换的开销也比线程切换的开销大得多。
5. 通信：由于同一进程中的多个线程具有相同的地址空间，他们之间的同步和通信也更容易。进程间通信（IPC），线程可以直接读写进程数据段（如全局变量）进行通信--需要进程同步和互斥来确保数据一致性，在某些操作系统中，线程可以在不需要操作系统内核干预的情况下进行切换、同步和通信。
6. 进程编程和调试简单可靠，但创建和销毁成本高，线程则相反，线程具有低开销、快速切换，但相对复杂的编程和调试
7. 进程间不会相互影响，而一个线程挂掉那么它的进程整个也会挂掉
8. 进程适用于多核、多机分布，线程适用于多核

## 进程线程如何通信？

进程间通信主要包括管道Channel、系统IPC（消息队列、信号量、信号、共享内存等）、以及套接字Socket

## 计算机内核态和用户态的概念

用户态指非特权状态，在此状态下，执行的代码被硬件限定，不能进行某些操作，比如写入其他进程的存储空间，以防止给操作系统带来安全隐患。

在操作系统的设计中，用户态也类似，指非特权的执行状态，内核禁止此状态下的代码进行潜在危险的操作，比如写入系统配置文件、杀掉其他用户的进程、重启系统等。

## 虚拟地址怎么映射到物理地址？

CPU在获得虚拟地址之后，需要通过MMU将虚拟地址翻译为物理地址，MMU根据虚拟地址在页表中寻址

*MMU*是Memory Management Unit的缩写，中文名是内存管理单元

## 死锁的解决方法

死锁的产生是在这样一种环境中：比如我们现有两个进程A和B，他们都需要资源一和资源二，当进程A持有资源一，进程B持有资源二的时候，他们都需要对方手上的资源，而一般操作系统又不允许抢占现象，这时就发生了死锁：

从这里总结出死锁的几个必要条件：

1. 一个资源只能被一个进程所占有，不能共享
2. 一个进程请求资源失败时，它会等待而不是释放
3. 一个进程在释放资源之前其他进程不能抢夺资源
4. 由此产生了循环死等待

从死锁产生的原因，可以设计出一些方法来避免死锁的发生：

1. 静态分配资源：一开始就把一个进程所需要的全部资源都分配给它，但这样会降低资源的使用效率
2. 允许抢占，需要设置进程的不同优先级，高优先级的进程可以抢占低优先级的进程的资源
3. 把资源进行编号，申请资源时必须按照资源的编号顺序进行申请

如果死锁已经发生了，就需要解开死锁，其本质思想就是分配资源以打破死循环：

1. 可以运行抢占，从一个或多个进程中抢出资源来给其他进程
2. 也可以终止一些进程，来达到释放资源的目的

## 简述进程切换的流程

如果想要从A进程切换到B进程，必定要先从用户态切换至内核态，这个切换的草案做不能让用户进程去实现，不然当CPU在用户进程手上的时候，他可以选择一直执行，不让出CPU资源，这必然是不合理且不允许的。

因此，操作系统需要先挂起正在占用CPU的A进程，才能切换至B进程。

由于从用户态切换到内核态的时候，CPU是出于用户进程手中，所以这个是通过硬中断来实现的，在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。

这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等，

一个进程的上下文可以分为用户级上下文、寄存器上下文、系统级上下文，

用户级上下文存储的是用户进程的内存数据以及堆栈数据等，

寄存器上下文是一些通用寄存器，

系统级上下文是内核栈、PCB（进程控制块）等。

## 简述IO多路复用

IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作，没有文件句柄就绪时会阻塞应用程序，交出CPU。

IO是指网络IO，多路指多个TCP连接（即socket或者channel），复用指复用一个或几个线程，意思是说一个或一组线程处理多个TCP连接。

最大的优点就是减小了系统开销，不必创建过多的进程/线程，也不必维护这些进程/线程。

IO多路复用的三种实现方式：select、poll、epoll