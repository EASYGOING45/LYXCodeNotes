# 操作系统-Part6

## 19、线程通信方法（Linux和Windows下）

![image-20230408080800346](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20230408080800346.png)

### Linux

| **Linux：**                                    |
| ---------------------------------------------- |
| 信号：类似进程间的信号处理                     |
| 锁机制：互斥锁、读写锁和自旋锁                 |
| 条件变量：使用通知的方式解锁，与互斥锁配合使用 |
| 信号量：包括无名线程信号量和命名线程信号量     |

### Windows

| **Windows：**                                                |
| ------------------------------------------------------------ |
| 全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 |
| Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 |
| CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法 |

## 20、详细描述一下进程间通信方式

Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中，前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。

### 管道

- 无名管道
  - 无名管道特点：
    - 无名管道是一种特殊的文件，这种文件只存在于内存中
    - 无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信
    - 无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。
  - 相关接口
    - `int pipe(int fd[2]);`
    - `fd[2]`：管道两端用 `fd[0]`和 `fd[1]`来描述，读的一端用 `fd[0]`表示，写的一端用 `fd[1]`表示。通信双方的进程中写数据的一方需要把 `fd[0]`先close掉，读的乙方需要先把 `fd[1]`给close掉
- 有名管道
  - 有名管道特点：
    - 有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出
    - 有名管道可以在不具有亲缘关系的进程间进行通信
  - 相关接口：
    - `int mkfifo(const char* pathname,model_t mode);`
    - `pathname`：即将创建的FIFO文件路径，如果文件存在需要先删除
    - `mode`：和 `open()`中的参数相同

### 消息队列

相比于FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法
- 读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收。

### 共享内存

进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。

- 相关接口

  - 创建共享内存：`int shmget(key_t key,int size,int flag);`

    - 成功时返回一个和key相关的共享内存标识符，失败范围为-1
    - key:为共享内存段命名，多个共享同一片内存的进程使用同一个key
    - size：共享内存容量
    - flag：权限标志位，和open的mode参数一样

  - 连接到共享内存地址空间：`void* shmat(int shmid,void* addr,int flag);`

    - 返回值即共享内存实际地址
    - shmid：shmget()返回的标识
    - addr：决定以什么方式连接地址。
    - flag：访问模式。

  - 从共享内存分离：int shmdt(const void *shmaddr);

    调用成功返回0，失败返回-1。

    - shmaddr：是shmat()返回的地址指针。

共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。

但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。

### 信号量

在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。

- 相关接口

  - 创建信号量： `int semget(key_t key,int nsems,int semflag);`

    - 创建成功返回信号量标识符，失败返回-1
    - key:进程pid
    - nsems：创建信号量的个数
    - semflag：指定信号量读写权限

  - 改变信号量值 ：`int semop(int semid,struct sembuf *sops,unsigned nsops);`

    - 我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去

    - struct sembuf结构体定义如下：

    - ```C
      struct sembuf{
          short sem_num;
          short sem_op;
          short sem_flg;
      };
      ```

    - 成功返回信号量标识符，失败返回-1。

    - semid：信号量集标识符，由semget()函数返回。

    - sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。

    - nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。

  - 直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);

    - semid：信号量集标识符。
    - semnum：信号量集数组上的下标，表示某一个信号量。
    - arg：union semun类型

### 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

## 21、虚拟内存的目的是什么？

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。

这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中，当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。

例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。