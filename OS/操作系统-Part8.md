# 操作系统-Part8

## 26、讲一下你知道的线程锁

#### 互斥锁（mutex）

互斥锁属于 `sleep-waiting`类型的锁，例如在一个双核的机器上有两个线程A和B，他们分别运行在core 0 和core 1上。假设线程A想要通过 `pthread_mutex_lock`操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。

### 条件变量（cond）

### 自旋锁（spin）

自旋锁属于 `busy-waiting`类型的锁，如果线程A是使用 `pthread_spin_lock`操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。

虽然自旋锁的效率比互斥锁高，但是它的不足同样明显：

- 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。
- 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁
- 自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁的时间比较短的情况下。

## 27、逻辑地址与物理地址

编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 相对地址又称逻辑地址，绝对地址又称物理地址。

## 28、讲讲回收线程的几种方法

### 等待线程结束

`int pthread_join(pthread_t tid,void** retval);`

主线程调用，等待子线程退出并回收其资源，类似于进程中的 `wait/waitpid`回收僵尸进程，调用 `pthread_join`的线程会被阻塞。

- tid:创建线程时通过指针得到tid值
- retval:指向返回值的指针

### 结束线程

`void pthread_exit(void *retval);`

子线程执行，用来结束当前线程并通过 `retval`传递返回值，该返回值可通过 `pthread_join`获得。

retval:指向返回值的指针

### 分离线程

`int pthread_detach(pthread_t tid);`

主线程、子线程均可调用。主线程中 `pthread_detach(tid)`，子线程中 `pthread_detach(pthread_self())`，调用后和主线程分离，子线程结束时自己立即回收资源。

tid：创建线程时通过指针得到tid值

## 29、内存的覆盖是什么？有什么特点？

由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定去和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外村中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。

覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。

## 30、内存交换是什么？有什么特点？

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外村，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）

换入：把准备好竞争CPU运行的程序从辅存移到内存。

换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。