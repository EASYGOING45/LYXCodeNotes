​    

# 绿盟科技C++暑期实习面经

## 深挖项目

## 讲一下Django

Django是一个开源的Python Web框架，它遵循了MVC（Model-View-Controller）的设计模式，提供了一些强大的工具和API，用于快速开发高质量的Web应用程序。Django的主要特点包括：

1. 自动化的ORM（对象关系映射）系统，可轻松地与数据库进行交互。

2. 内置的模板引擎，可用于生成HTML、XML等各种格式的文档。

3. 内置的安全性机制，包括跨站请求伪造（CSRF）保护、XSS（跨站脚本攻击）过滤等。

4. 内置的认证和授权系统，可用于管理用户、组和权限。

前后端分离/不分离式设计是一种Web应用程序的设计模式，它将前端和后端分离开发，使得前端和后端可以独立开发、测试和部署。在前后端分离式设计中，前端主要负责页面的展示和用户交互，后端主要负责数据的处理和业务逻辑的实现。在前后端不分离式设计中，前端和后端是紧密耦合的，前端主要负责页面的展示和用户交互，后端主要负责数据的处理和页面的渲染。

前后端分离式设计的优点包括：

1. 提高开发效率：前后端可以独立开发，减少了开发人员之间的依赖性，提高了开发效率。

2. 提高代码质量：前后端分离可以使得代码更加清晰、易于维护和测试。

3. 提高可扩展性：前后端分离可以使得应用程序更加灵活，易于扩展。

前后端不分离式设计的优点包括：

1. 开发简单：前后端紧密耦合，可以减少开发人员之间的沟通和协调。

2. 性能更好：前后端不分离可以减少网络传输和请求，提高应用程序的性能。

3. 更好的用户体验：前后端不分离可以使得应用程序更加流畅、自然，提供更好的用户体验。

总的来说，前后端分离式设计适合大型、复杂的Web应用程序，而前后端不分离式设计适合小型、简单的Web应用程序。

## 常用的设计模式有哪些？

常用的设计模式有23种，它们可以分为三类：创建型、结构型和行为型。

1. 创建型模式

创建型模式关注对象的创建过程，主要包括以下几种：

- 工厂模式：定义一个用于创建对象的接口，由子类决定实例化哪一个类。
- 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
- 单例模式：确保一个类只有一个实例，并提供一个全局访问点。
- 原型模式：通过复制现有的实例来创建新的实例。

2. 结构型模式

结构型模式关注对象之间的组合，主要包括以下几种：

- 适配器模式：将一个类的接口转换成客户希望的另一个接口。
- 桥接模式：将抽象部分与实现部分分离，使它们可以独立变化。
- 组合模式：将对象组合成树形结构以表示"部分-整体"的层次结构。
- 装饰器模式：动态地给一个对象添加一些额外的职责。
- 外观模式：为子系统中的一组接口提供一个一致的界面，以简化使用。
- 享元模式：运用共享技术来有效地支持大量细粒度对象的复用。

3. 行为型模式

行为型模式关注对象之间的通信，主要包括以下几种：

- 职责链模式：将请求的发送者和接收者解耦，使多个对象都有机会处理这个请求。
- 命令模式：将请求封装成对象，从而可以用不同的请求对客户进行参数化。
- 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用于解释语言中的句子。
- 迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
- 中介者模式：用一个中介对象来封装一系列的对象交互。
- 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
- 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
- 状态模式：允许一个对象在其内部状态发生改变时改变它的行为。
- 策略模式：定义一系列的算法，把它们一个个封装起来，并使它们可以相互替换。
- 模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中实现。
- 访问者模式：表示一个作用于某个对象结构中的各个元素的操作，它使得可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。

以上就是常用的23种设计模式，它们各有特点，可以根据具体的应用场景来选择适合的模式。

## GET与POST的区别

GET和POST是HTTP协议中最常用的两种请求方法，它们的主要区别如下：

1. 参数传递方式不同

- GET请求：参数会以URL的形式附加在URL后面，形如：http://www.example.com/index.php?param1=value1&param2=value2。因此，GET请求的参数有长度限制，一般不能超过2KB。
- POST请求：参数会以表单的形式提交到请求体中，不会在URL上显示，因此POST请求的参数没有长度限制。

2. 安全性不同

- GET请求：因为参数会以明文的形式附加在URL上，所以不太安全，容易被其他人截获或者篡改。而且，GET请求的参数也会被浏览器缓存，容易造成安全问题。
- POST请求：参数在请求体中，不会被浏览器缓存，相对比较安全。

3. 适用场景不同

- GET请求：一般用于获取数据，比如查询、搜索等操作。
- POST请求：一般用于提交数据，比如注册、登录、修改密码等操作。

总之，GET和POST各有优缺点，具体使用哪种请求方法需要根据实际需求来确定。

## TCP/IP四层模型

TCP/IP 网络模型是一种参考模型，用于描述计算机网络中通信的基本原理和规则。它由四个层次组成，分别是应用层、传输层、网络层和数据链路层。

1. 应用层：应用层提供了网络应用程序与网络之间的接口，包括文件传输、电子邮件、网页浏览等。常见的应用层协议有 HTTP、FTP、SMTP、POP3 等。

2. 传输层：传输层负责数据的可靠传输，包括数据分段、传输控制和错误恢复等功能。常见的传输层协议有 TCP 和 UDP。

3. 网络层：网络层负责数据包的路由和转发，实现网络之间的通信。常见的网络层协议有 IP、ICMP 和 ARP。

4. 数据链路层：数据链路层负责将数据包转换为物理信号，实现数据在物理链路上的传输。常见的数据链路层协议有以太网、PPP 和 SLIP。

TCP/IP 网络模型架构是一种开放式的架构，可以方便地添加新的协议和功能，因此被广泛应用于互联网和局域网等计算机网络中。

## 进程与线程的区别和联系

进程和线程是操作系统中的基本概念，它们的区别和联系如下：

1. 定义

- 进程：一个正在执行中的程序的实例，包括代码、数据和所需的资源。
- 线程：进程中的一个执行单元，是操作系统调度的最小单位。

2. 资源占用

- 进程：独立的内存空间、文件句柄、网络连接等资源。
- 线程：与父进程共享内存空间、文件句柄、网络连接等资源。

3. 调度

- 进程：由操作系统负责进程之间的切换，进程切换时会保存当前进程的上下文并恢复下一个进程的上下文。
- 线程：由操作系统负责线程之间的切换，线程切换时只需保存和恢复线程的上下文，并不需要切换进程的上下文。

4. 并发性

- 进程：进程之间是互相独立的，一个进程的崩溃不会影响其他进程的执行。
- 线程：多个线程共享同一个进程的资源，一个线程的崩溃会影响整个进程的执行。

5. 通信

- 进程：进程之间通信需要通过进程间通信（IPC）的机制，如管道、消息队列、共享内存等。
- 线程：线程之间通信可以直接读写共享内存或者使用同步机制。

联系：

- 进程是线程的容器，一个进程可以包含多个线程。
- 线程可以共享进程的资源，如内存空间、文件句柄、网络连接等。
- 线程之间可以共享数据，也可以通过同步机制来保证数据的一致性。

总之，进程和线程是操作系统中的重要概念，它们在资源占用、调度、并发性和通信等方面有着明显的区别和联系。对于程序的设计和优化，需要根据实际情况选择合适的进程和线程模型来实现。

## 进程间通信方式

进程间通信（IPC）是指不同进程之间交换数据或信息的过程。在操作系统中，进程间通信的方式主要有以下几种：

1. 管道（Pipe）

管道是一种半双工的通信方式，它可以在两个进程之间传递数据。管道有两种类型：匿名管道和命名管道。匿名管道只能在有亲缘关系的进程之间使用，而命名管道可以在不同进程之间共享。

2. 消息队列（Message Queue）

消息队列是一种全双工的通信方式，它可以在不同进程之间传递数据。消息队列中的数据可以按照优先级进行排序，接收方可以选择接收哪个优先级的数据。

3. 共享内存（Shared Memory）

共享内存是一种高效的通信方式，它可以在不同进程之间共享同一块物理内存。共享内存的优点是速度快，但需要考虑数据的同步和互斥问题。

4. 信号量（Semaphore）

信号量是一种用于进程同步的机制，它可以防止多个进程同时访问共享资源。信号量通常与共享内存一起使用，用于保证多个进程之间的数据同步。

5. 套接字（Socket）

套接字是一种网络通信方式，它可以在不同主机之间进行通信。套接字通常用于客户端和服务器之间的通信，可以传输文本、二进制数据等。

以上几种进程间通信方式都有各自的优缺点，需要根据实际需求来选择合适的方式。在实际开发中，通常会结合多种通信方式来实现进程间的数据交换和同步。

## 线程间通信方式

1. 共享内存：多个线程共享同一块内存区域，通过对该内存区域的读写来进行通信。

2. 信号量：通过对共享资源的访问来进行同步和互斥，控制各个线程的访问顺序。

3. 互斥锁：通过对共享资源的访问来进行同步和互斥，保证在任意时刻只有一个线程可以访问共享资源。

4. 条件变量：线程之间通过条件变量来等待或者通知某个事件的发生，实现线程的协调和同步。

5. 管道：管道是一种半双工的通信方式，可以用于两个线程之间的通信，其中一个线程负责写入数据，另一个线程负责读取数据。

6. 消息队列：消息队列是一种异步的通信方式，发送方将消息发送到队列中，接收方从队列中获取消息，实现线程之间的通信和协调。

7. 套接字：套接字是一种网络通信方式，可以用于不同进程或不同计算机之间的通信。

## select和epoll的区别

select和epoll都是Linux系统中用于I/O多路复用的机制。

select是最早出现的I/O多路复用机制，它的原理是在内核中维护一个文件描述符集合，通过select系统调用将需要监控的文件描述符添加到集合中，然后阻塞进程等待事件发生。当有文件描述符就绪时，select返回，并将就绪的文件描述符集合返回给进程，进程再通过遍历集合来处理就绪的文件描述符。select的缺点是效率较低，因为每次需要遍历整个集合，而且集合大小有限。

epoll是Linux内核2.5版本引入的I/O多路复用机制，它的原理是在内核中维护一个事件表，通过epoll_ctl系统调用将需要监控的文件描述符添加到事件表中，然后阻塞进程等待事件发生。当有文件描述符就绪时，epoll返回，并将就绪的文件描述符及其事件类型返回给进程，进程再通过遍历返回的列表来处理就绪的文件描述符。epoll的优点是效率高，因为它只需要遍历就绪的文件描述符，而且能够处理大量的文件描述符，因为事件表大小没有限制。

总体来说，epoll比select效率更高，能够处理更多的文件描述符，但是epoll的实现比select更加复杂。在实际应用中，需要根据具体情况选择合适的I/O多路复用机制。