# 蚂蚁面试准备-C++

## Reactor 模型（为什么用Reactor，Reactor解决了什么实际问题，假设线程池有100个线程，但有1000个用户同时使用，Reactor的具体表现，前端用户的体验是什么样的）和 Proactor模型

Reactor模型是一种事件驱动的设计模式，它适用于高并发、高负载的应用程序。在Reactor模型中，应用程序将事件发送到事件处理器，事件处理器将事件分派到相应的处理函数进行处理。处理函数在事件处理器的线程池中执行，从而避免了在多线程环境下的线程竞争及线程切换的开销，提高了系统的性能和可靠性。

Reactor模型的优点在于其能够提高应用程序的并发性和可扩展性，在大量用户同时访问时，可以保持系统的稳定性，而不会因为超负荷而崩溃。假设线程池有100个线程，当有1000个用户同时使用时，Reactor将在短时间内对事件进行处理，从而避免出现瓶颈问题。

前端用户的体验是很好的，因为Reactor模型能够确保应用程序的高并发性和稳定性，这意味着用户可以快速地获得响应并保持良好的用户体验。同时，Reactor模型通过事件处理器和线程池的优化提高了系统的性能和吞吐量，使得用户的操作更加快速和流畅。

Proactor模型，与Reactor模型类似，也是一种事件驱动的设计模式，但在处理事件时，它采用异步IO的方式进行操作，通过将IO操作交给系统来处理，可以有更高的效率和可扩展性。与Reactor模型不同的是，Proactor模型将IO操作的结果封装成一个处理函数，并通过回调函数的方式进行调用，从而避免了应用程序的阻塞。

Proactor模型的优点在于其能够提供高效的IO 操作和可扩展性，同时也不会影响应用程序的响应时间。在大量IO操作场景下，Proactor模型能够更好地处理并发和吞吐量，提高应用程序的性能和可靠性。

## IO多路复用的流程和原理

IO多路复用是一种高效的IO操作方式，它允许应用程序在同一时间内监听多个文件描述符的IO事件，从而避免了在传统的阻塞IO模型下的线程资源浪费和效率低下问题。

一般来说，IO多路复用流程包括以下几个步骤：

1. 构建事件集合：应用程序会通过系统调用如select、poll或epoll（Linux特有）等，向系统内核注册需要监听IO事件的文件描述符，同时将相应的事件和处理函数进行封装。
2. 调用多路复用函数：应用程序会调用多路复用函数，向其传递已注册的事件集合及timeout值，并在该函数的内部进入阻塞状态。
3. 等待事件发生：内核会监控所有已注册的文件描述符，当文件描述符有IO事件发生时，它会将该事件的状态信息存到内核空间的某个数据结构中。
4. 通知应用层处理：当事件发生时，内核会唤醒调用多路复用函数的进程或线程，并将触发事件的文件描述符以及其IO状态（如是否可读、是否可写等）传递给应用程序。
5. 处理IO事件：应用程序通过处理函数对IO事件进行响应和处理，当处理完成后，可以通过上述步骤再次监听事件或关闭文件描述符。

IO多路复用的原理在于：通过系统调用向内核注册需要监听IO事件的文件描述符，从而将IO操作的等待和处理交由内核处理，避免了阻塞式的IO对系统性能的影响。对于大量的IO操作，IO多路复用能够有效提高系统的处理能力和性能。同时，由于IO多路复用是基于事件驱动的操作方式，这种模型可以提高应用程序的响应速度和用户体验。

## epoll、poll、select特点和区别

epoll、poll和select都是Linux中用于实现IO多路复用的机制，它们可以同时监听多个文件描述符的IO事件，从而提高了系统的性能和效率。它们的主要特点和区别如下：

- ### epoll

特点：

- 使用“事件的就绪通知”方式而非轮询方式，可以避免遍历文件描述符列表。
- 采用单独的事件注册和移除接口，可以有效管理大量的文件描述符。
- 提供了EPOLLONESHOT事件，可以确保每个事件只被一个线程处理。
- 支持边缘触发和水平触发两种模式。

区别：

- epoll不需要将每个文件描述符都复制到内核空间，因此效率高于poll和select。
- 可以在Linux 2.6内核以上使用。

- ### poll

特点：

- 使用轮询方式来监听文件描述符的IO事件。
- 采用结构体数组来记录注册的文件描述符状态和事件，支持大量的文件描述符。
- 支持边缘触发和水平触发两种模式。

区别：

- 相比于select，poll能够管理的文件描述符数量更多。
- 在大量文件描述符的场景下，效率低于epoll。

- ### select

特点：

- 使用轮询方式来监听文件描述符的IO事件。
- 采用fd_set数据结构记录注册的文件描述符状态和事件，支持大量的文件描述符。
- 支持边缘触发和水平触发两种模式。

区别：

- 可以对标准输入、标准输出和标准错误输出等文件描述符进行处理，而poll和epoll不能。
- 在大量文件描述符的场景下，效率低于epoll。

综上所述，从效率、可用性等方面分析，epoll通常是最优选择，它具有较高的性能和可扩展性，可以有效解决高并发IO场景下的问题。

## 为什么裸写socket编程而不是使用一些成熟的协议

裸写socket编程的主要原因是因为一些特殊的需求或限制，需要对网络通信进行更加细粒度的控制和定制。以下是一些可能需要使用裸写socket编程的场景：

1. 极致性能要求：一些高性能的应用场景，如游戏服务器、高频交易等，需要实现最少的网络延迟和最小的带宽占用，因此需要使用裸写socket编程来减少不必要的协议开销和数据处理时间。
2. 自定义协议：如果应用程序需要实现比较特殊或自定义的协议，而已有的协议无法满足需求，则需要使用裸写socket编程。
3. 操作系统或硬件的限制：有些操作系统或硬件上可能不支持某些成熟的协议，比如TCP协议的流控制机制对实时信号传输来说不够理想，此时需要使用裸写socket编程实现定制化的网络通信。

当然，并不是所有的情况都建议使用裸写socket编程。在大多数情况下，使用已有的成熟协议能够更加方便高效地完成网络通信任务。使用成熟协议可以节省开发时间和测试时间，同时避免了一些细节问题和潜在的漏洞。因此，在进行网络通信时，需要根据具体业务需求，权衡使用成熟协议和裸写socket编程的利弊。

## 为什么使用条件变量时总会使用互斥锁

在使用条件变量时，总会使用互斥锁来保证线程安全和避免死锁的问题。

条件变量是一种线程之间用来通信和协作的机制，它能够唤醒等待在条件变量上的线程并让它们重新竞争锁资源。但是在这个过程中，由于多线程并发执行的特性，可能会出现多个线程同时竞争同一资源的情况。为了防止竞争造成的数据错误和线程安全问题，需要使用互斥锁来排他性地保护资源的访问。

另外，使用条件变量时，为避免死锁问题，需要先获得互斥锁，然后才能等待或唤醒条件变量。这是因为如果在等待或唤醒条件变量时不加锁，可能会出现多个线程同时访问和修改共享资源的情况，从而导致死锁问题。

因此，使用条件变量时总会使用互斥锁来保证线程安全和避免死锁问题。大多数情况下，条件变量与互斥锁往往是一起使用的，称之为“条件变量与互斥锁配对使用”。

## 讲讲黑白盒测试

黑盒测试和白盒测试是常用的软件测试方法。它们关注的角度和测试目标不同，主要有以下几个区别：

- #### 测试角度不同：

黑盒测试是从外部用户的角度出发进行测试的，只关注软件的功能是否符合需求和规格说明。测试人员没有访问代码的权力，他们只能根据软件的输入和输出来进行测试。

白盒测试则是从程序开发者角度出发进行测试的，主要测试程序的内部结构、逻辑与程序代码是否符合程序规范。测试人员有权利访问并测试程序代码，并进行逻辑上的细致检查。

- #### 测试目的不同：

黑盒测试主要是确认软件是否符合用户的需求和规格说明，找出软件中的错误和缺陷。它的主要目的是通过对软件外部行为的检测和验证，从而保证软件的质量、可靠性和安全性。

白盒测试主要是发现程序代码的逻辑错误和代码缺陷，确保程序在逻辑上的正确性，以及软件能够有效地满足各个部分之间的协作关系。它的主要目的是验证程序的设计、代码实现和程序结构是否符合规范和标准。

- #### 测试方法不同：

黑盒测试通常采用输入输出测试法、等价类划分法、边界值分析法、决策表测试法、状态转换测试法等测试方法。

白盒测试通常采用语句覆盖率、判断覆盖率、条件覆盖率、路径覆盖率等覆盖测试方法和调试器等工具对程序代码进行检查。

综上所述，黑盒测试和白盒测试是两种不同的测试方法，它们的主要区别在于测试角度和目的的不同。具体用哪种测试方法，取决于测试人员的需求和目标，以及测试场景的不同。