"""

牛牛组织了一场拉力赛，在一条水平的赛道上，共有n辆赛车，在当前时刻，牛牛记录下来了从左到右每辆车的位置p1,p2,...,pn,假设起点处位置为0，因此它们当前的排名依次为：n,n-1,n-2,....,1
现在牛牛知道在位置pi处的车辆速度为vi，假设所有的车保持匀速行驶，牛牛想知道在t个单位时间后，有多少赛车的排名上升了？
注：如果在t个单位时间后有两辆车的位置相同，则这两辆车的排名相同，一辆车的排名为在它前面的车辆的个数加1

输入描述：
第一行输入两个正整数n，t
第二行输入n个由空格隔开的整数p1,p2,...,pn
第三行输入n个由空格隔开的整数v1,v2,...,vn

输出t个单位时间之后排名上升的赛车数量

样例输入：
3 1
1 2 3
3 1 3
预期输出：1 说明：原本排行在3的车在1个单位时间后到了4，而原本在第2的车在1个单位时间后到达位置3，而排行在第1的车位置到达了6，因此只有1辆车的排名上升了
"""


"""
首先，从输入中获取赛车数量n和单位时间t。
然后，从输入中获取每辆赛车的初始位置列表positions和速度列表speeds。
接下来，使用循环计算每辆赛车在t个单位时间后的位置，将结果存储在新的位置列表new_positions中。这里使用了速度乘以时间的公式。
然后，使用sorted函数对排名列表进行排序，排序的依据是新位置列表new_positions中的值。这样，ranks列表中的元素将按照新位置从小到大的顺序排列。
接着，使用sum函数和列表推导式计算有多少辆赛车的排名上升了。对于每个索引i，如果ranks[i]小于i，则说明赛车的排名上升了，将其计入count变量中。
最后，输出计数变量count，即排名上升的赛车数量。
"""

# 通过率72.73%

n, t = map(int, input().split())
positions = list(map(int, input().split()))
speeds = list(map(int, input().split()))

# 计算每辆车在t个单位时间后的位置
new_positions = [positions[i] + speeds[i] * t for i in range(n)]

# 计算每辆车在t个单位时间后的排名
ranks = sorted(range(n), key=lambda x: new_positions[x])

# 计算排名上升的赛车数量
count = sum(ranks[i] < i for i in range(n))

print(count)
