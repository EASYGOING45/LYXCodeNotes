# Redis的五种数据结构+使用场景

一、String（字符串）

​	在Redis中，字符串可以被修改，称为简单动态字符串（SDS）或字符串，但它的结构更像数组列表，维护字节数组并在其中预分配空间，减少频繁的内存分配。

​	Redis的内存分配机制如下：

1. 当字符串长度小于1MB时，每次扩容会使现有空间翻倍
2. 如果字符串长度超过1MB，则每次只扩展1MB空间
3. 这确保了足够的内存空间，并且不会浪费内存，字符串的最大长度是512MB

```C++
struct SDS{T capacity;       //数组容量
  T len;            //实际长度
  byte flages;  //标志位,低三位表示类型
  byte[] content;   //数组内容
}
```

​	上面是字符串的基本结构，其中content保存字符串的内容，0x\0 作为结束字符不计算在 len中。

> ​	capacity和len属性都是泛型的，为何不直接使用int？
>
> ​	Redis 中有很多优化方案。为了更合理地使用内存，不同长度的字符串用不同的数据类型表示。此外，len 在创建字符串时与capacity 一样大，因此不会产生多余的空间。所以 String 值可以是字符串、数字(整数、浮点数)或二进制。
>

应用场景：存储key-value键值对

二、list（列表）

​	当数据量较小时，它的底层存储结构是一个连续的内存，称为ziplist（压缩列表），它将所有的元素彼此相邻地存储，分配的是一个连续的内存，当数据量较大时，将其转换为快速列表结构。

​	然而，简单的链表也有缺陷，链表前后的指针prev和next将占用更多的内存，浪费更多的空间，并加剧内存碎片。

​	Redis3.2之后，采用了ziplist+链表的混合结构，称为quicklist（快速链表）

应用场景：由于list是按照插入顺序排序的列表，因此有许多应用场景，例如：

1. 消息队列：lpop和rpush（反之，lpush和rpop）可以实现队列的功能
2. 朋友圈的列表、评论列表和排行榜：lpush命令和lrange命令可以实现最新列表的功能，每次通过lpush命令插入新的元素到列表中，再通过lrange命令读取最新的元素列表

三、Hash（字典）

​	数组+列表结构，当发生散列冲突时将元素添加到列表中。

​	注意，Redis Hash值只能是字符串，Hash和String都可以用来存储用户信息，但不同点在于Hash可以分别存储用户信息的每个字段，存储所有用户信息的序列化字符串。

​	如果要修改用户字段，必须先查询所有用户信息字符串，解析为对应的用户信息对象，修改后再序列化为字符串。

​	但是，哈希只可以修改某个字段，从而节省网络流量，而哈希的内存占用比String大，这是Hash的缺点。

应用场景：

1. 购物车：`hset[key][field][value]`命令可以实现用户id，商品id为字段，商品数量为值，正好构成了购物车
2. 散列类型（键、字段、值）的结构类似于对象（对象id、属性、值）的结构，也可以用来存储对象

四、set（集合）

​	set内部的键值对是无序的、唯一的。它内部的实现相当于一个特殊的字典，字典中所有的value都是一个值NULL。

​	当集合中最后一个元素被移除之后，数据结构被自动删除，内存被回收。

应用场景：

1. 散列类型（键、字段、值）的结构类似于对象（对象id、属性、值）的结构，也可以用来存储对象。
2. 收集朋友、追随者、粉丝等：
   1. 使用sinter命令可以获取用户A和B的共同好友
   2. sismember命令可以判断A是否是B的朋友
   3. scard命令可以获取好友数量
   4. smove命令可以将B从A的风扇集转移到A的朋友集
3. 首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set 类型适合存放所有需要展示的内容，而 srandmember 命令则可以从中随机获取几个。
4. 存储某活动中中奖的用户 ID ，因为有去重功能，可以保证同一个用户不会中奖两次。

五、zset（有序集合）

​	zset也成为sortedset，一方面，它是一个集合，它保证了内部值的唯一性。另一方面，它可以为每个值分配一个分数，表示该值的排序权重。它的内部实现使用一种称为“跳转列表”的数据结构。

应用场景：

1. zset 可以用作排序，但与 list 不同的是，它可以实现动态排序。
2. 例如，zset 可以用来存储风扇列表。value 为球迷的用户ID, score 为接下来的时间。

zset 还可以用来存储学生的成绩，其中 value 是学生的ID, score 是他的考试成绩。我们可以按分数给他打分。