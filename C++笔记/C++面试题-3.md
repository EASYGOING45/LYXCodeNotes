# C++面试题-3

### 21、什么是野指针？

野指针不是NULL指针，是未初始化或者未清零的指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存。成因：

1、指针变量没有被初始化

2、指针指向的内存被释放了，但是忘记了给指针置NULL

3、指针超过了变量的作用范围，比如b[10]，指针b+11

### 22、C++中内存泄漏的几种情况

内存泄漏是指动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

1. 类的构造函数和析构函数中new和delete没有配套
2. 在释放对象数组时没有使用delete[]，使用了delete
3. 没有将积累的析构函数定义为虚函数，当基类指针指向子类对象时，如果积累的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄漏
4. 没有正确的清除嵌套的对象的指针

### 23、栈溢出的原因以及解决方法

栈溢出是指函数中的局部变量造成的溢出（注：函数中形参和函数中的局部变量存放在栈上）

栈的大小通常是1M-2M，所以栈溢出包含两种情况：

​	一是分配的大小超过栈的最大值

​	二是分配的大小没有超过最大值，但是接受的buffer比原buffer小

1. 函数调用层次过深，每调用一次，函数的参数、局部变量等信息就压一次栈
2. 局部变量体积太大

解决办法大致也有两种：

> 1. 增加栈内存的数目，如果是不超过栈大小但是分配值小的，就增大分配的大小
> 2. 使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针，然后动态申请内存，也可以把局部变量变成全局变量，一个偷懒的办法是直接在定义前边价格static，直接变成静态变量（实质就是全局变量）

### 24、左值和右值

不太严谨的说：

左值指的是既能够出现在等号左边也能出现在等号右边的变量（或表达式），右值指的则是只能出现在等号右边得到变量（或表达式）。

​	举例来说我们定义的变量a就是一个左值，而malloc返回的就是一个右值。或者左值就是在程序种能够寻址的东西，右值就是一个具体的真实的值或者对象，没法取到它的地址的东西（不完全准确），因此没法对右值进行赋值，但是右值并非是不可修改的，比如自己定义的class，可以通过它的成员函数来修改右值。

归纳一下就是：可以取地址的，有名字的，非临时的就是左值不能取地址的，没有名字的，临时的，通常生命周期就在某个表达式之内的就是右值，但是到了C++11之后概念变得略微复杂，引入了lvalue,glvalue,rvalue,xvalue和prvalue

### 25、左值引用和右值引用

左值引用就是我们通常所说的引用，如下所示：左值引用通常可以看作是变量的别名

```C++
type-id & cast-expression
//demo
int a = 10
int &b = a

int &c = 10 //错误，无法对一个立即数做引用
const int &d = 10  //正确，常引用引用常熟量是ok的
//常引用等价于const int temp = 10
//			const int &d = temp
```

右值引用是C++11新增的特性，其形式如下所示，右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期

- 右值引用支持移动语义的实现，可以减少拷贝，提升程序的执行效率
- 右值引用可以使重载函数变得更加简介，右值引用可以适用const T& 和 T&形式的参数

```c++
type-id && cast-expression

//demo
int &&var=10;	//ok

int a = 10
int &&b = a		//错误，a为左值

int &&c=var		//错误，var为左值

int &&d = move(a)	//ok,通过move得到左值的右值引用
```

在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量，但是唯一一点的区别是：右值引用可以进行读写擦从左，而常引用只能进行读操作

### 26、头文件中的ifndef/define/endif是干什么用的？该用法和pragma once的区别？

相同点：它们的作用是防止头文件被重复包含

不同点：

1. ifndef 由语言本身提供支持，但是pragma once一般由编译器提供支持，也就是说，有可能出现编译器不支持的情况（主要是比较老的编译器）

2. 通常运行速度上ifndef一般慢于pragma once，特别是在大型项目上，区别会比较明显，所以越来越多的编译器开始支持pragma once

3. ifndef作用于某一段被包含（define和endif之间）的代码，而pragma once则是针对包含该语句的文件，这也是为什么pragma once速度更快的原因

4. 如果用ifndef包含某一段宏定义，当这个宏名字出现“撞车”时，可能会出现这个宏在程序中提示宏未定义的情况（在编写大型程序时特别需要注意，因为有很多程序员在同时写代码）。

   相反，由于pragma once针对整个文件，因此它不存在宏名字“撞车”的情况，但是如果某个头文件被多次拷贝，pragma once无法保证不被多次包含，因为pragma once是从物理上判断是不是同一个头文件，而不是从内容上

### 27、指针数组和数组指针的区别

数组指针，是指向数组的指针，而指针数组则是指该数组的元素均为指针。

1. 数组指针，是指向数组的指针，其本质为指针，形式如下。如 int (*p)[n]，p 即为指向数组的指针，() 优先级高，首先说明 p 是一个指针，指向一个整型的一维数组，这个一维数组的长度是 n，也可以说是 p 的步长。也就是说执行 p+1 时，p 要跨过 n 个整型数据的长度。数组指针是指向数组首元素的地址的指针，其本质为指针，可以看成是二级指针。

   `类型名 (*数组标识符)[数组长度]`

2. 指针数组，在 C 语言和 C++ 中，数组元素全为指针的数组称为指针数组，其中一维指针数组的定义形式如下。指针数组中每一个元素均为指针，其本质为数组。如 int *p[n]， [] 优先级高，先与 p 结合成为一个数组，再由 int* 说明这是一个整型指针数组，它有 n 个指针类型的数组元素。这里执行 p+1 时，则 p 指向下一个数组元素，这样赋值是错误的：p=a；因为 p 是个不可知的表示，只存在 p[0]、p[1]、p[2]…p[n-1], 而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里* p 表示指针数组第一个元素的值，a 的首地址的值。

   `类型名 *数组标识符[数组长度]`

### 28、C++是不是类型安全的？

不是，两个不同类型的指针之间可以强制转换

### 29、main函数执行之前，还会执行什么代码？

全局对象的构造函数会在main函数之前执行

### 30、全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？

生命周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁，局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在

使用方式不同：通过声明后全局变量程序的各个部分都可以用到，局部变量只能在局部使用，分配在栈区

内存分配位置不同：全局变量分配在全局数据段并且在程序开始运行的时候被加载，局部变量则分配在堆栈里面