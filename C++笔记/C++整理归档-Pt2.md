# C++整理归档-Pt2

## C++与Java的区别

语言特性：

- Java语言提供了更为简洁的语法，完全面向对象，JVM的可移植性强
- Java语言中没有指针的概念，引入了真正的数组，解决了C++中由于指针导致的不安全问题
- C++也可以在其他系统运行，但是需要不同的编码
- Java用接口（Interface）技术取代C++程序中的抽象类，接口省却了在实现和维护上的复杂性

垃圾回收

- C++使用析构函数回收垃圾，C和C++程序一定要注意内存的申请和释放
- Java语言不用指针，内存的分配和回收都是自动的，程序员无需考虑内存碎片的问题

应用场景

- Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，能够直接对内存操作，但同时具有危险性。
- Java更适合于Web应用的编写开发
- 对于底层程序的编程以及控制方面的编程，C++由于句柄的存在所以很灵活

## C++中struct和class的区别

相同点：

- 两者都拥有成员函数、公有和私有部分
- 任何可以使用class完成的工作，都可以使用struct完成

不同点：

- 两者中如果不对成员指定公私有，struct默认是共有的，class则默认是私有的
- class默认继承方式为private，struct默认为public。

引申：C和C++中的struct的区别

- C语言中，struct是用户自定义数据类型（UDT），C++中struct是抽象数据类型（ADT），支持成员函数的定义，C++中的struct能继承，能够实现多态
- C中的struct没有权限的设置， 且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）
- struct作为类的一种特例是用来自定义数据结构的，一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（typedef struct class{}; 除外）
- C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当做类的一种特例

## define宏定义和const的区别

编译阶段：

- define是在编译的预处理阶段起作用，const是在编译、运行的时候起作用

安全性：

- define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
- const常量有数据类型，编译器可以对其进行类型安全检查

内存占用：

- define只是将宏名称进行替换，在内存中会产生多份相同的辈分，const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果并放入常量表中
- 宏替换发生在编译阶段之前，属于文本插入替换，const作用发生于编译过程中
- 宏不检查类型，const会检查数据类型
- 宏定义的数据没有分配内存空间，只是插入替换掉，const定义的变量只是值不能改变，但要分配内存空间

## C++中const和static的作用

### static

不考虑类的情况：

- 隐藏，所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
- 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
- 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用

考虑类的情况：

- static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static，可以被非static成员函数任意访问
- static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数，不能被声明为const、虚函数和volatile。

### const

不考虑类的情况

- const常量在定义时必须初始化，之后无法更改
- const形参可以接收const和非const类型的实参，例如 // i可以是int型 或者 const int 型 void fun(const int &i){//...}

考虑类的情况

- const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须具有构造函数，不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
- const成员函数：const对象不可以调用非const成员函数，非const对象都可以调用，不可以改变非mutable（用该关键字声明的变量可以在const成员函数被修改）数据的值

> const修饰变量也与static有一样的隐藏作用。但只能在该文件中使用，其他文件不可以引用声明使用，因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。

## C++中的顶层const和底层const

### 概念

- 顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是*号右边
- 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是*号左边

```C++
int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量
const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量
const int b3 = 20; 		   //顶层const，b3是常量不可变
const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
const int& b5 = a;		   //用于声明引用变量，都是底层const
```

### 区分作用

- 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const
- 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const

```C++
const int a;int const a;const int *a;int *const a;
```

- `int const a `和 `const int a`均表示定义常量类型a
- `const int *a`其中a为指向int型变量的指针，const在*左侧，表示a指向不可变常量。（可以视为 `const(*a)，对引用加const`
- `int *const a`依旧是指针类型，表示a为指向整型数据的长指针（`视为const(a)`，对指针const）