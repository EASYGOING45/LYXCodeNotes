# C++体系构建-Part3

> C++三大特性

## 访问权限

- C++提供public、protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。
- 在类的内部（定义类的代码内部），无论成员被声明为public、protected还是private，都是可以互相访问的，没有访问权限的限制。
- 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问public属性的成员，不能访问private、protected属性的成员
- 无论共用继承、私有和保护继承，私有成员不能被“派生类”访问，基类中的共有和保护成员能被“派生类”访问
- 对于共有继承，只有基类中的共有成员能被“派生类对象”访问，保护和私有成员不能被“派生类对象”访问
- 对于私有和保护继承，基类中的所有成员不能被“派生类对象访问

## 继承

- 定义：让某种类型对象获得另一个类型对象的属性和方法
- 功能：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
- 常见的继承有三种方式：
  - 实现继承：使用基类的属性和方法而无需额外编码
  - 接口继承：仅使用属性和方法的名称，但是子类必须提供重新实现
  - 可视继承：指子窗体（类）和基窗体（类）的外观和实现代码的能力

> 将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法。

## 封装

- 定义：数据和代码捆绑在一起，避免外界干扰和不确定性访问
- 功能：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
  - 例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰

## 多态

- 定义：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为
  - （重载实现编译时多态，虚函数实现运行时多态）
- 功能：多态性是允许将父对象设置成为和一个或更多个他的子对象相等类别的技术，
  - 赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作
- 简单说，就是`允许将子类类型的指针赋值给父类类型的指针`
- 实现多态的方式：
  - 覆盖（override）：是指子类重新定义父类的虚函数的做法
  - 重载（overload）：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，也可能两者都不同）

> 举例：
>
> 基类是⼀个抽象对象——⼈，那学⽣、运动员也是⼈，⽽使⽤这个抽象对象既可以表示学⽣、 也可以表示运动员。 

## 虚函数

当基类希望派生类定义适合自己的版本，就将这些函数声明成虚函数（virtual）

虚函数依赖函数表工作，表来保存虚函数地址，当我们用基类指针指向派生类时，虚表指针指向派生类的虚函数表

这个机制也可以保证派生类中的虚函数能够被调用到

1. 虚函数是动态绑定的
   1. 也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数，这是虚函数的基本功能
2. 多态（不同继承关系的类对象，调用同一函数产生不同行为）
   1. 调用函数的对象必须是指针或者引用
   2. 被调用的函数必须是虚函数（virtual），且完成了虚函数的重写（派生类中有一个跟基类的完全相同虚函数）
3. 动态绑定绑定的是动态类型
   1. 所对应的函数或属性依赖于对象的动态模型，发生在运行期
4. 构造函数不能是虚函数
   1. 而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有被构造好的情况下，多态是被禁用的
5. 虚函数的工作方式
   1. 依赖虚函数表工作，表来保存虚函数地址，当使用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表
   2. 这个机制可以保证派生类中的虚函数被调用到
6. 析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的
7. 将一个函数定义为纯虚函数
   1. 实际上是将这个类定义为抽象类，不能实例化对象
   2. 纯虚函数通常没有定义提，但也完全可以拥有
8. inline，static，constructor三种函数都不能带有virtual关键字
   1. inline是在编译时展开，必须要有实体
      1. 内联函数是指在编译期间用被调用函数体本身来代替函数的调用指令
      2. 但虚函数的多态特性需要在运行时根据对象类型才知道调用哪个虚函数，所以没办法在编译时进行内联函数展开
   2. static属于class自己的类相关，必须有实体
      1. static成员没有this指针，virtual函数一定要通过对象来调用，有隐藏的this指针，实例相关
9. 析构函数可以是纯虚的
   1. 但是纯虚的析构函数必须有定义提，因为析构函数的调用是在子类中隐含的
10. 派生类的override虚函数定义必须和父类完全一致
    1. 除了一个特里，如果父类中的返回值是一个指针或者引用，子类override时可以返回这个指针（或引用）的派生

## 为什么需要虚继承？

1. 为了解决多继承时的命名冲突和冗余数据问题
   1. C++提出了虚继承，使得在派生类中只保留一份间接基类的成员
   2. 其中多继承（Multiple Inheritance），是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员
2. 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类
   1. 其中这个被共享的基类就成为虚基类（Virtual Base Class），其中A就是一个虚基类
   2. 在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。
   3. 类A有一个成员变量a，不使用虚继承，那么在类D中直接访问a就会产生歧义。
   4. 编译器不知道他究竟来自A->B->D这条路径，还是来自A->C->D这条路径
   5. ![image-20230110214122568](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20230110214122568.png)

- C++标准库中的iostream类就是一个虚继承的实际应用案例
- iostream从istream和ostream直接继承而来，而istream和ostream又都继承自一个共同的名为baseios的类，是典型的菱形继承
- 此时istream和ostream必须采用虚继承，否则将导致iostream类中保留两份baseios类的成员
- ![image-20230110214547125](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20230110214547125.png)
- 使用多继承的话就经常容易出现二义性，必须十分小心
- 一般只有在比较简单和不易出现二义性或者实在必要的情况下才使用多继承，能用单一继承解决问题就不要用多继承