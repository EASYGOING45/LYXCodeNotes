# C++体系构建-Part5

## C++强制类型转换

> 关键字：static_cast、dynamic_cast、reinterpret_cast、const_cast

### static_cast

- 没有运行时类型检查来保证转换的安全性
- 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
- 进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以不安全
- 使用：
  - 用于几倍数据类型之间的转换，如把int转换成char
  - 把任何类型的表达式转换成void类型

### dynamic_cast

- 在进行下行转换时，dynamic_cast具有类型检查（信息在虚函数中）的功能，比static_cast更安全
- 转换后必须是类的指针、引用或者void*，基类要有虚函数，可以交叉转换
- dynamic本身只能用于存在虚函数的父子关系的强制类型转换；对于指针、转换失败则返回nullptr
  - 对于引用，转换失败则会抛出异常

### reinterpret_cast

- 可以将整型转换为指针，也可以把指针转换为数组
- 可以在指针和引用里进行肆无忌惮的转换
- 平台移植性价比差

### const_cast

- 常量指针转换为非常量指针，并且仍然指向原来的对象。
- 常量引用被转换为非常量引用，并且仍然指向原对象。
- 可以用于去掉类型的const或volatile属性

# C++内存模型

## 常见的字符串函数的实现

### strcpy()

把从strstc地址开始且含有'\0'结束符的字符串复制到以strdest开始的地址空间，返回值的类型为char*

<img src="https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20230112165615570.png" alt="image-20230112165615570" style="zoom:150%;" />

### strlen()

用于计算给定字符串的长度

<img src="https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20230112165710341.png" alt="image-20230112165710341" style="zoom:150%;" />

assert用于下断言

### strcat()

作用是把src所指字符串添加到dest结尾处

<img src="https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20230112165818412.png" alt="image-20230112165818412" style="zoom:150%;" />

### strcmp()

- 比较两个字符串，设这两个字符串为str1、str2
- 若str1==str2 则返回零
- 若str1<str2 则返回负数
- 若str1>str2 则返回正数

<img src="https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20230112170002669.png" alt="image-20230112170002669" style="zoom:150%;" />

## 内存泄漏

### 什么是内存泄漏？

内存泄漏（memory leak）是指由于疏忽或错误造成了`程序未能释放掉不再使用的内存`的情况。

内存泄漏并非指内存在物理意义上的消失，而是应用程序分配某段内存后，由于涉及错误，失去了对该段内存的控制，因而造成了内存的浪费。

可以使用`Valgrind`、`mtrace`进行内存泄漏检查

### 内存泄漏的分类

1. 堆内存泄漏（Heap leak）
   1. 堆内存指的是程序运行中根据需要分配通过mallloc、realloc、new等从堆中分配的一块内存，再是完成后必须通过调用的free或者delete删掉。
   2. 如果程序设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，此时就产生了 Heap Leak
2. 系统资源泄漏（Resource Leak）
   1. 主要指程序使用系统分配的资源比如Bitmap、Handle、SOCKET等没有使用相应的函数释放掉，导致资源的浪费，严重可导致系统效能降低，系统运行不稳定
3. 没有将基类的虚构函数定义为虚函数
   1. 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类中的析构函数将不会被调用，子类的资源没有正确释放，因而造成内存泄漏

### 什么操作会导致内存泄漏？

指针指向改变、未释放动态分配内存

### 如何防止内存泄漏？

将内存的分配封装在类中，构造函数分配内存、析构函数释放内存；使用智能指针等等。

### 智能指针

智能指针是为了解决动态分配内存导致内存泄漏和多次释放同意内存所提出的，C11标准中放在<memory>头文件中，包括：共享指针、独占指针、弱指针

## 构造函数、析构函数要设为虚函数吗？

1. 析构函数
   1. 析构函数需要
   2. 当派生类对象中有内存需要回收时，如果析构函数不是虚函数，不会触发动态绑定，只会调用基类析构函数，导致派生类资源无法释放，造成内存泄漏
2. 构造函数
   1. 构造函数不需要，没有意义
   2. 虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型
   3. 要创建一个对象，需要知道对象的完整信息，尤其是需要知道想要创建的确切类型，因此构造函数不应该被定义为虚函数