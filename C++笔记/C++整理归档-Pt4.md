# C++整理归档-Pt4

## 野指针和悬空指针

都是指向无效内存区域（即“不安全不可控”的区域）的指针，访问行为将会导致未定义行为发生。

### 野指针

野指针，指的是没有被初始化过的指针

```C++
int main(void)
{
    int* p;	//未初始化
    std::cout<<*p<<std::endl;	//未初始化就被使用
    
    return 0;
}
```

因此，为了防止出错，对于指针初始化时都是赋值为`nullptr`，这样在使用时编译器就不会直接报错，产生非法内存访问。

### 悬空指针

悬空指针，指针最初指向的内存已经被释放了的一种指针。

```C++
int main(void)
{
    int *p=nullptr;
    int*p2 = new int;
    
    p = p2;
    
    delete p2;
}
```

此时，p和p2就是悬空指针，指向的内存已经被释放，继续使用这两个指针，行为不可预料，需要设置为 `p=p2=nullptr;`此时再使用，编译器会直接报错，避免野指针比较简单，但是悬空指针比较麻烦。

C++引入了智能指针，其本质目的就是避免悬空指针的产生。

### 产生原因及解决办法：

野指针：指针变量未及时初始化    定义指针变量时应及时初始化，或者置空

悬空指针：所指向的指针free或者delete之后没有及时置空  释放操作后立即指控

## C和C++的类型安全

### 什么是类型安全？

类型安全很大程度上等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”的代码不会视图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制，有的时候也用类型安全来形容某个程序，判别的标准在于该程序是否会隐含类型错误。

类型安全的编程语言与类型安全的程序之间，没有必然联系，目前暂时还没有绝对类型安全的编程语言。

### C的类型安全

C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器就会报告错误，除非使用显式类型转换。C中相当多的操作时不安全的，以下是两个常见例子：

- printf格式输出

  ![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341869.png)

  上述代码中，使用 `%d`控制整型数字的输出，没有问题，但是改成 `%f`时，明显输出错误，再改成 `%s`时，运行直接报 `segmentation fault`错误

- malloc函数的返回值

  malloc是C中进行内存分配的函数，它的返回类型是 `void`即空类型指针，常常有这样的用法 `char* pStr=(char*)malloc(100*sizeof(char));`这里很明显，做了显式的类型转换

  类型匹配尚且没有问题，但是一旦出现 `int* pint=(int*)malloc(100*sizeof(char));`时就很可能带来一些问题，而这样的转换C中并不会提示错误

### C++的类型安全

如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：

- 操作符new返回的指针类型严格与对象匹配，而不是void*
- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换
- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全
- C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

例：使用void*进行类型转换

![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341679.png)

例：不同类型指针之间转换

```C++
#include<iostream>
using namespace std;
 
class Parent{};
class Child1 : public Parent
{
public:
	int i;
	Child1(int e):i(e){}
};
class Child2 : public Parent
{
public:
	double d;
	Child2(double e):d(e){}
};
int main()
{
	Child1 c1(5);
	Child2 c2(4.1);
	Parent* pp;
	Child1* pc1;
 	
	pp=&c1; 
	pc1=(Child1*)pp;  // 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误
	cout<<pc1->i<<endl; //输出：5
 
	pp=&c2;
	pc1=(Child1*)pp;  //强制转换，且类型发生变化，将造成错误
	cout<<pc1->i<<endl;// 输出：1717986918
	return 0;
}

```

上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针`void*`，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针`void*`，尽量不对两种类型指针做强制转换。