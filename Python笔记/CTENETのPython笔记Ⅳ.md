# CTENETのPython笔记Ⅳ

## 函数的定义&调用&返回值

### 函数

数学定义

- y=f(x) ，y是x的函数，x是自变量。y=f(x0, x1, ..., xn)

Python函数

- 由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元
- 完成一定的功能

函数的作用

- 结构化编程对代码的最基本的封装，一般按照功能组织一段代码
- 封装的目的为了复用，减少冗余代码
- 代码更加简洁美观、可读易懂

函数的分类

- 内建函数，如max()、reversed()等
- 库函数，如math.ceil()等
- 自定义函数，使用def关键字定义

### 函数定义

```python
def 函数名(参数列表):
	函数体（代码块）
	[return 返回值]
```

- 函数名就是标识符，命名要求一样
- 语句块必须缩进，约定4个空格
- Python的函数若没有return语句，会隐式返回一个None值
- 定义中的参数列表称为形式参数，只是一种符号表达（标识符），简称形参

### 函数调用

- 函数定义，只是声明了一个函数，它不能被执行，需要调用执行
- 调用的方式，就是函数名后加上小括号，如有必要在括号内填写上参数
- 调用时写的参数是实际参数，是实实在在传入的值，简称实参

```python
def add(x, y): # 函数定义
	result = x + y # 函数体
	return result # 返回值

out = add(4,5) # 函数调用，可能有返回值，使用变量接收这个返回值
print(out) # print函数加上括号也是调用
```

上面代码解释：

- 定义一个函数add，及函数名是add，能接受2个参数
- 该函数计算的结果，通过返回值返回，需要return语句
- 调用时，通过函数名add后加2个参数，返回值可使用变量接收
- 函数名也是标识符
- 返回值也是值
- 定义需要在调用前，也就是说调用时，已经被定义过了，否则抛NameError异常
- 函数是可调用的对象，callable(add)返回True

### 函数返回值

- Python 函数使用 return 语句返回“返回值”
- 所有函数都有返回值，如果没有return语句，隐式调用return None
- return 语句并不一定是函数的语句块的最后一条语句
- 一个函数可以存在多个return语句，但是只有一条可以被执行。如果没有一条return语句被执行到，隐式调用return None
- 如果有必要，可以显示调用return None，可以简写为return
- 如果函数执行了return语句，函数就会返回，当前被执行的return语句之后的其它语句就不会被执行了
- 返回值的作用：结束函数调用、返回“返回值”
- 函数不能同时返回多个值
- return 1, 3, 5 看似返回多个值，隐式的被python封装成了一个元组
- x, y, z = showlist() 使用解构提取返回值更为方便

## 函数参数

函数在定义时要定义好形式参数，调用时也提供足够的实际参数，一般来说，形参和实参个数要一致（可变参数除外）。

### 实参传参方式

1. 位置传参

   定义时def f(x,y,z) 调用使用f(1,3,5),按照参数定义顺序传入实参

2. 关键字传参

   定义时def f(x,y,z),调用使用f(x=1,y=3,z=5),使用形参的名字来传入实参的方式，如果使用了形参名字，那么传参顺序就可和定义顺序不同

   要求位置参数必须在关键字参数之前传入，位置参数是按位置对应的

   > 切记：传参指的是调用时传入实参，就2种方式

## 形参

### 形参缺省值

缺省值也称为默认值，可以在函数定义时，为形参增加一个缺省值。其作用：

- 参数的默认值可以在未传入足够的实参的时候，对没有给定的参数赋值为默认值
- 参数非常多的时候，并不需要用户每次都输入所有的参数，简化函数调用

### 可变参数

需求：写一个函数，可以对多个数累加求和

```python
def sum(iterable):
	s = 0
	for x in iterable:
		s += x
	return s

print(sum([1,3,5]))
print(sum(range(4)))
```

上例，传入可迭代对象，并累加每一个元素。

也可以使用可变参数完成上面的函数。

```python
def sum(*nums):
	sum = 0
	for x in nums:
		sum += x
	return sum

print(sum(1, 3, 5))
print(sum(1, 2, 3))
```

1、可变位置参数

- 在形参前使用 * 表示该形参是可变位置参数，可以接受多个实参
- 它将收集来的实参组织到一个 tuple 中

2、可变关键字参数

- 在形参前使用 ** 表示该形参是可变关键字参数，可以接受多个关键字参数
- 它将收集来的实参的名称和值，组织到一个dict中

总结：

- 有可变位置参数和可变关键字参数
- 可变位置参数在形参前使用一个星号*
- 可变关键字参数在形参前使用两个星号**
- 可变位置参数和可变关键字参数都可以收集若干个实参，可变位置参数收集形成一个tuple，可变关键字参数收集形成一个dict
- 混合使用参数的时候，普通参数需要放到参数列表前面，可变参数要放到参数列表的后面，可变位置参数需要在可变关键字参数之前

### keyword-only参数

在python3之后，新增了keyword-only参数

keyword-only参数：在形参定义时，在一个*星号之后，或一个可变位置参数之后，出现的普通参数，就已经不是普通的参数了，称为keyword-only参数

keyword-only参数，言下之意就是这个参数必须采用关键字传参。

### positional-only参数

python3.8开始，增加了最后一种形参类型的定义：Positional-only参数。

```python
def fn(a, /):
	print(a, sep='\n')
fn(3)
fn(a=4) # 错误，仅位置参数，不可以使用关键字传参
```

### 参数规则

参数列表参数一般顺序是：positional-only参数、普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数。 注意：

- 代码应该易读易懂，而不是为难别人
- 请按照书写习惯定义函数参数
- 定义最常用参数为普通参数，可不提供缺省值，必须由用户提供。注意这些参数的顺序，最常用的先定义
- 将必须使用名称的才能使用的参数，定义为keyword-only参数，要求必须使用关键字传参
- 如果函数有很多参数，无法逐一定义，可使用可变参数。如果需要知道这些参数的意义，则使用可变关键字参数收集

### 参数解构

- 在给函数提供实参的时候，可以在可迭代对象前使用*或者 ** 来进行结构的解构，提取出其中所有元素作为函数的实参
- 使用*解构成位置传参
- 使用**解构成关键字传参
- 提取出来的元素数目要和参数的要求匹配

## 作用域

一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域

```python
def foo():
	x = 100
print(x) # 可以访问到吗
```

上例中x不可以访问到，会抛出异常（NameError: name 'x' is not defined），原因在于函数是一个封装，它会开辟一个作用域，x变量被限制在这个作用域中，所以在函数外部x变量不可见。

> 注意：每一个函数都会开辟一个作用域

### 作用域分类

- 全局作用域 
  - 在整个程序运行环境中都可见
  - 全局作用域中的变量称为全局变量global
- 局部作用域 
  - 在函数、类等内部可见
  - 局部作用域中的变量称为局部变量，其使用范围不能超过其所在局部作用域
  - 也称为本地作用域local

### 函数嵌套

在一个函数中定义了另外一个函数

```python
def outer():
	def inner():
		print("inner")
	inner()
	print("outer")
outer() # 可以吗？ 可以
inner() # 可以吗？ 不可以
```

内部函数inner不能在外部直接使用，会抛NameError异常，因为它在函数外部不可见。

其实，inner不过就是一个标识符，就是一个函数outer内部定义的变量而已。

**嵌套结构的作用域**

对比下面嵌套结构，代码执行的效果

```python
def outer1(): #
    o = 65
    def inner():
        print("inner {}".format(o))
        print(chr(o))

    inner()
    print("outer {}".format(o))

outer1() # 打印结果
#inner 65
#A
#outer 65

def outer2(): #
    o = 65
    def inner():
        o = 97
        print("inner {}".format(o))
        print(chr(o))

    inner()
    print("outer {}".format(o))

outer2() # 打印结果
#inner 97
#a
#outer 65
```

从执行的结果来看：

- 外层变量在内部作用域可见
- 内层作用域 inner 中，如果定义了 `o = 97` ，相当于在当前函数 inner 作用域中重新定义了一个新的变量o，但是，***这个 o 并不能覆盖掉外部作用域 outer2 中的变量 o***。只不过对于 inner 函数来说，其只能可见自己作用域中定义的变量 o 了

| 内建函数 | 函数签名 | 说明                        |
| -------- | -------- | --------------------------- |
| chr      | chr(i)   | 通过unicode编码返回对应字符 |
| ord      | ord(c)   | 获得字符对应的unicode       |

```python
print(ord('中'), hex(ord('中')), '中'.encode(), '中'.encode('gbk'))
print(chr(20013)) # '中'
print(chr(97))
```

### global 语句

```python
x = 5
def foo():
    global x # 全局变量
    x += 1
    print(x)
foo()
```

- 使用 global 关键字的变量，将 foo 内的 x 声明为使用外部的全局作用域中定义的 x
- 全局作用域中必须有 x 的定义
- 使用了global，foo中的x不再是局部变量了，它是全局变量。

#### **总结**

- `x+=1` 这种是特殊形式产生的错误的原因？先引用后赋值，而 python 动态语言是赋值才算定义，才能被引用。解决办法，在这条语句前增加 x=0 之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义
- 内部作用域使用 `x = 10` 之类的赋值语句会重新定义局部作用域使用的变量x，但是，一旦这个作 用域中使用 global 声明x为全局的，那么`x=10`相当于在为全局作用域的变量x赋值

**global使用原则**

- 外部作用域变量会在内部作用域可见，但也不要在这个内部的局部作用域中直接使用，因为函数的目的就是为了封装，尽量与外界隔离
- 如果函数需要使用外部全局变量，请尽量使用函数的形参定义，并在调用传实参解决
- 一句话：不用global。学习它就是为了深入理解变量作用域

### 闭包

**自由变量**：未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量

**闭包**：就是一个概念，出现在嵌套函数中，指的是**内层函数引用到了外层函数的自由变量**，就形成了闭包。很多语言都有这个概念，最熟悉就是JavaScript

```python
def counter():
    c = [0]
    def inc():
        c[0] += 1 # 报错吗？ 为什么 # line 4
        return c[0]
    return inc
foo = counter() # line 8
print(foo(), foo()) # line 9
c = 100
print(foo()) # line 11
```

代码分析

- 第8行会执行 counter 函数并返回 inc 对应的函数对象，注意这个函数对象并不释放，因为有 foo 记着
- 第4行会报错吗？为什么 
  - 不会报错，c 已经在 counter 函数中定义过了。而且 inc 中的使用方式是为 c 的元素修改值，而不是重新定义 c 变量
- 第9行打印什么结果？ 
  - 打印 1 2
- 第11行打印什么结果？ 
  - 打印 3
  - 第9行的 c 和 counter 中的 c 不一样，而 inc 引用的是自由变量正是 counter 中的变量 c

这是 Python2 中实现闭包的方式，Python3 还可以使用 nonlocal 关键字

再看下面这段代码，会报错吗？使用 global 能解决吗？

```python
def counter():
    count = 0
    def inc():
        count += 1
        return count
    return inc

foo = counter()
print(foo(), foo())
```

上例一定出错，使用gobal可以解决

```python
def counter():
    global count
    count = 0
    def inc():
        global count
        count += 1
        return count
    return inc

foo = counter()
print(foo(), foo())
count = 100
print(foo()) # 打印几？ 101
```

上例使用 global 解决，这是全局变量的实现，而不是闭包了。

如果要对这个普通变量使用闭包，Python3中可以使用nonlocal关键字。

### nonlocal 语句

**nonlocal**：将变量标记为不在本地作用域定义，而是在**上级的某一级局部作用域**中定义，但**不能是全局****作用域中定义**。

```python
def counter():
    count = 0
    def inc():
        nonlocal count # 声明变量count不是本地变量
        count += 1
        return count
    return inc

foo = counter()
print(foo(), foo())
```

count 是外层函数的局部变量，被内部函数引用。

内部函数使用 nonlocal 关键字声明 count 变量在上级作用域而非本地作用域中定义。

代码中内层函数引用外部局部作用域中的自由变量，形成闭包。

```python
count = 10
def counter():
    nonlocal count
    count += 1
    return count

foo = counter()
print(foo(), foo())
```

上例是错误的，nonlocal 声明变量 a 不在当前作用域，但是往外就是全局作用域了，所以错误。

### 函数的销毁

定义一个函数就是生成一个函数对象，函数名指向的就是函数对象。

可以使用 del 语句删除函数，使其引用计数减1。

可以使用同名标识符覆盖原有定义，本质上也是使其引用计数减1。

Python 程序结束时，所有对象销毁。

函数也是对象，也不例外，是否销毁，还是看引用计数是否减为0。

### 变量名解析原则LEGB

- Local，本地作用域、局部作用域的 local 命名空间。函数调用时创建，调用结束消亡
- Enclosing，Python2.2 时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间
- Global，全局作用域，即一个模块的命名空间。模块被 import 时创建，解释器退出时消亡
- Build-in，内置模块的命名空间，生命周期从 python 解释器启动时创建到解释器退出时消亡。例如print(open)，print 和 open 都是内置的变量

所以一个名词的查找顺序就是LEGB

![LEGB](https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/LEGB.png)

| 内建函数  | 函数签名                 | 说明                                                         |
| --------- | ------------------------ | ------------------------------------------------------------ |
| iter      | iter(iterable)           | 把一个可迭代对象包装成迭代器                                 |
| next      | next(iterable[,default]) | 取迭代器下一个元素 如果已经取完，继续取抛StopIteration异常   |
| reversed  | reversed(seq)            | 返回一个翻转元素的迭代器                                     |
| enumerate | enumerate(seq, start=0)  | 迭代一个可迭代对象，返回一个迭代器 每一个元素都是数字和元素构成的二元组 |

## 递归函数

### 简介

在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。

举个例子，我们来计算阶乘`n! = 1 x 2 x 3 x ... x n`，用函数`fact(n)`表示，可以看出：

![image-20210622160651079](https://gitee.com/clay-wangzhi/blogImg/raw/master/blogImg/image-20210622160651079.png)

所以，`fact(n)`可以表示为`n x fact(n-1)`，只有n=1时需要特殊处理。

于是，`fact(n)`用递归的方式写出来就是：

```text
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```

上面就是一个递归函数。可以试试：

```text
>>> fact(1)
1
>>> fact(5)
120
>>> fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
```

如果我们计算`fact(5)`，可以根据函数定义看到计算过程如下：

```ascii
===> fact(5)
===> 5 * fact(4)
===> 5 * (4 * fact(3))
===> 5 * (4 * (3 * fact(2)))
===> 5 * (4 * (3 * (2 * fact(1))))
===> 5 * (4 * (3 * (2 * 1)))
===> 5 * (4 * (3 * 2))
===> 5 * (4 * 6)
===> 5 * 24
===> 120
```

递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试`fact(1000)`：

```text
>>> fact(1000)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in fact
  ...
  File "<stdin>", line 4, in fact
RuntimeError: maximum recursion depth exceeded in comparison
```

解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的`fact(n)`函数由于`return n * fact(n - 1)`引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

```text
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

可以看到，`return fact_iter(num - 1, num * product)`仅返回递归函数本身，`num - 1`和`num * product`在函数调用前就会被计算，不影响函数调用。

`fact(5)`对应的`fact_iter(5, 1)` 的调用如下：

```text
===> fact_iter(5, 1)
===> fact_iter(4, 5)
===> fact_iter(3, 20)
===> fact_iter(2, 60)
===> fact_iter(1, 120)
===> 120
```

尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的`fact(n)`函数改成尾递归方式，也会导致栈溢出。

### 输出斐波那契数列

```python
def recur_fibo(n):
    """递归函数
   输出斐波那契数列
   """
    if n <= 1:
        return n
    else:
        return (recur_fibo(n - 1) + recur_fibo(n - 2))


# 获取用户输入
nterms = int(input("您要输出几项? "))
for i in range(nterms):
    print(recur_fibo(i), end=" ")
```

### 小结

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题