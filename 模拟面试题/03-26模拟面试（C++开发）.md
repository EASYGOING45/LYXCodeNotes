# 03-26模拟面试（C++开发）

## 简单做一个自我介绍

## 聊一下项目吧

### 聊聊树洞项目，如何实现的前后端架构？

### 树洞项目中使用了哪些技术框架和语言？

### 树洞项目中你的数据库用的是什么?有没有做什么优化？

## 服务器项目

### 讲一下你对Boost库的了解

Boost库是一个C++库集合，它包含了许多现代C++编程中常用的工具和库，例如智能指针、线程、正则表达式、容器、算法等等。Boost库的目标是提供高质量的、可移植的C++源代码库，以帮助C++开发人员更快、更高效地开发应用程序。

### 讲一下你对于Muduo库的了解

Muduo是一个基于C++11的高性能网络库，它提供了一系列的网络编程组件，包括TCP/UDP的服务器和客户端、线程池、定时器等等。Muduo的设计目标是提供高性能、高效、易扩展的网络编程框架。

Muduo采用了Reactor模式，通过事件驱动的方式进行网络编程，这种方式相比于传统的多线程或多进程方式，能够更好的利用资源，提高并发处理能力。Muduo还采用了多线程的技术，通过线程池的方式来处理网络请求，提高系统的吞吐量和性能。

Muduo的核心组件包括EventLoop、Channel、Acceptor、TcpConnection等等，这些组件都是基于事件驱动的方式实现的，能够快速响应网络事件，提高系统的响应速度和性能。

### 讲一下你对于分布式的了解，什么是集群式分布式

分布式系统是指由多个独立计算机（节点）组成的系统，这些节点通过网络互相通信和协作，共同完成一个任务。分布式系统的目标是提高系统的可靠性、可扩展性、可用性和性能。

集群式分布式系统是一种常见的分布式系统架构，它由多个计算机（节点）组成一个集群，每个节点都可以独立运行和处理任务，同时也可以共同处理任务。集群式分布式系统可以提高系统的可靠性、可扩展性和性能，因为当集群中的某个节点出现故障时，其他节点可以接管其任务，保证系统的正常运行。

### 你是如何实现集群式分布式的？展开说说

Redis 订阅-发布消息队列

Redis是一种高性能的内存数据库，支持订阅-发布消息队列。订阅-发布模式是一种消息通信模式，其中发送者（发布者）发送消息，而接收者（订阅者）接收消息。

在Redis中，订阅-发布模式由两个命令实现：

1. PUBLISH：发布消息。使用PUBLISH命令向指定的频道发布一条消息。
2. SUBSCRIBE：订阅频道。使用SUBSCRIBE命令订阅一个或多个频道，以接收发布到这些频道的消息。

## 网络

### 聊一下TCP/IP四层体系结构

TCP/IP体系结构是一种计算机网络协议体系结构，由传输控制协议（TCP）和互联网协议（IP）组成。它定义了一系列协议，用于在互联网上进行数据通信。

TCP/IP体系结构分为四个层次：

1. 应用层：应用层协议定义了应用程序之间的通信规则，包括HTTP、FTP、SMTP等协议。

2. 传输层：传输层协议提供了端到端的数据传输服务，包括TCP和UDP协议。

3. 网络层：网络层协议定义了数据在网络上的传输规则，包括IP协议。

4. 链路层：链路层协议定义了数据在物理链路上的传输规则，包括以太网、ATM、PPP等协议。

TCP/IP体系结构是互联网的核心协议体系结构，它的设计思想是灵活、可扩展的，已经成为了计算机网络领域最为重要的协议体系结构之一。

### 聊一下TCP和UDP，及使用场景

TCP和UDP都是网络协议，用于在计算机网络中传输数据。

TCP（Transmission Control Protocol）是一种面向连接的协议，它通过建立连接、传输数据和断开连接的方式来保证数据的可靠性。TCP会对传输的数据进行分割、排序、确认和重传，确保数据的完整性和正确性。TCP适用于对数据传输质量要求较高的应用，如文件传输、电子邮件、网页浏览等。

UDP（User Datagram Protocol）是一种无连接的协议，它不会对传输的数据进行排序、确认和重传，因此传输速度更快，但可靠性较低。UDP适用于对数据传输速度要求较高，但对数据完整性要求较低的应用，如视频流、音频流、实时游戏等。

使用场景：

TCP适用于对数据传输质量要求较高的应用，如文件传输、电子邮件、网页浏览等。

UDP适用于对数据传输速度要求较高，但对数据完整性要求较低的应用，如视频流、音频流、实时游戏等。

总之，TCP和UDP各有优缺点，应根据具体应用场景选择合适的协议。

### 聊一下HTTPS和HTTP以及他们各自的优缺点

HTTP（Hypertext Transfer Protocol）是一种用于传输超文本的协议，它是一种无状态的协议，每个请求和响应之间是独立的，无法保持会话状态，也无法防止信息被篡改。

HTTPS（Hypertext Transfer Protocol Secure）是基于HTTP的安全协议，它使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议进行加密通信，确保数据传输的安全性和完整性。 HTTPS比HTTP更安全，因为它使用加密技术来保护数据传输，同时也能够验证服务器的身份，防止中间人攻击。

HTTP的优点是它是一种简单、易于实现和使用的协议，适用于大多数的应用程序。HTTP的缺点是它不安全，因为数据传输是明文的，容易被窃取和篡改。另外，HTTP也无法防止重放攻击和会话劫持。

HTTPS的优点是它提供了更高的安全性和数据完整性，可以防止数据被窃取和篡改，同时也能够防止中间人攻击。HTTPS还能够验证服务器的身份，确保通信双方的身份安全。HTTPS的缺点是它比HTTP更复杂、更耗费资源和更难以实现，需要使用证书和加密技术来实现安全传输，也需要消耗更多的服务器资源和带宽。

总的来说，HTTP适用于一些不需要传输敏感信息的简单应用场景，而HTTPS适用于需要保护敏感信息的安全传输场景，例如网上银行、电子商务等。

### 聊一下你知道的网络层常见协议，展开讲讲

| 协议 | 名称                 | 作用                                                         |
| ---- | -------------------- | ------------------------------------------------------------ |
| IP   | 网际协议             | IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择 |
| ICMP | Internet控制报文协议 | ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议 |
| RIP  | 路由信息协议         | 使用“跳数”(即metric)来衡量到达目标地址的路由距离             |
| IGMP | Internet组管理协议   | 用于实现组播、广播等通信                                     |

### TCP的拥塞控制算法有哪些？

拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。

### 聊一下Ping命令

ping是基于网络层的ICMP协议实现的。通过向对方发送一个**ICMP回送请求报文**，如果对方主机可达的话会收到该报文，并响应一个**ICMP回送回答报文**。

## 操作系统

### 聊一下进程、线程和协程

| 进程     | 线程                                                         | 协程                                               |                                                              |
| -------- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| 定义     | 资源分配和拥有的基本单位                                     | 程序执行的基本单位                                 | 用户态的轻量级线程，线程内部调度的基本单位                   |
| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄存器和栈的内容         | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复         |
| 切换者   | 操作系统                                                     | 操作系统                                           | 用户                                                         |
| 切换过程 | 用户态->内核态->用户态                                       | 用户态->内核态->用户态                             | 用户态(没有陷入内核)                                         |
| 调用栈   | 内核栈                                                       | 内核栈                                             | 用户栈                                                       |
| 拥有资源 | CPU资源、内存资源、文件资源和句柄等                          | 程序计数器、寄存器、栈和状态字                     | 拥有自己的寄存器上下文和栈                                   |
| 并发性   | 不同进程之间切换实现并发，各自占有CPU实现并行                | 一个进程内部的多个线程并发执行                     | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |
| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，因此开销很小   | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 |
| 通信方面 | 进程间通信需要借助操作系统                                   | 线程间可以直接读写进程数据段(如全局变量)来进行通信 | 共享内存、消息队列                                           |

### 线程与进程的区别？

1、线程启动速度快，轻量级

2、线程的系统开销小

3、线程使用有一定难度，需要处理数据一致性问题

4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈

### 进程调度算法你了解多少？

### 先来先服务（FCS）

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长

### 短作业优先（SJF）

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

### 最短剩余时间优先（SRTN）

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。

如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。

当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220000782.png)

### 优先级调度

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

### 多级反馈队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

### Linux下进程间通信方式？

- 管道：
  - 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。
  - 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。
- 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。
- 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。
- 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。
- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

## Linux

### 聊一下Linux下的常用IO模型

Linux下常用的IO模型包括阻塞式IO、非阻塞式IO、多路复用IO和异步IO。

1. 阻塞式IO：应用程序调用IO操作后，会一直等待直到IO操作完成，期间无法进行其他操作。这种方式的优点是简单易用，但缺点是效率低下，因为IO操作会阻塞整个进程。

2. 非阻塞式IO：应用程序调用IO操作后，如果IO操作不能立即完成，会立即返回一个错误码，应用程序可以继续执行其他操作。这种方式的优点是可以提高效率，但缺点是需要不断地轮询IO操作是否完成，因此会增加CPU负担。

3. 多路复用IO：应用程序通过select、poll或epoll等系统调用，同时监视多个IO操作，当任意一个IO操作完成时，应用程序可以立即处理该IO操作。这种方式的优点是可以同时处理多个IO操作，效率较高，但缺点是需要额外的系统调用和数据结构维护。

4. 异步IO：应用程序调用IO操作后，不需要等待IO操作完成，而是可以继续执行其他操作。当IO操作完成后，系统会通知应用程序进行处理。这种方式的优点是可以提高效率，但缺点是实现较为复杂，需要使用特定的API和事件回调函数。

不同的IO模型适用于不同的场景，应根据具体情况选择合适的IO模型。

### 聊一下epoll、select、poll

这三个都是Linux下的I/O多路复用机制，可以在一个进程中同时处理多个文件描述符的I/O事件。

select是最早的I/O多路复用机制，它使用fd_set结构体来存储所有需要监控的文件描述符，然后通过select函数来等待这些文件描述符中的任何一个就绪。但是select有一个缺点，就是它每次都需要遍历整个fd_set结构体，导致效率较低。

poll是对select的改进，它使用pollfd结构体来存储需要监控的文件描述符，然后通过poll函数来等待这些文件描述符中的任何一个就绪。poll的效率比select高，因为它只需要遍历就绪的文件描述符。

epoll是最新的I/O多路复用机制，它使用epoll_ctl函数来添加、修改、删除需要监控的文件描述符，然后通过epoll_wait函数来等待这些文件描述符中的任何一个就绪。epoll的效率比poll和select都要高，因为它使用了红黑树和事件通知机制来高效地处理大量的文件描述符。而且epoll还支持边缘触发和水平触发两种模式，可以更加灵活地处理I/O事件。

### 聊一下Linux下查看网络状态的命令

Linux下常用的查看网络状态的命令有以下几个：

1. ifconfig：用于显示网络接口的状态和配置信息，包括IP地址、子网掩码、MAC地址等。

2. netstat：用于显示网络连接、路由表、接口统计信息等，可以查看网络连接状态、端口占用情况等。

3. ping：用于测试网络连接的命令，可以测试网络连接是否畅通、延迟等信息。

4. traceroute：用于显示数据包从本机到目标主机经过的路由信息，可以用来排查网络连接问题。

5. tcpdump：用于抓取网络数据包，可以用来分析网络流量、排查网络故障等。

6. ss：用于显示套接字信息，包括TCP连接状态、监听端口等，可以查看系统的网络连接状态。

以上命令都是在Linux系统中常用的网络状态查看工具，可以帮助管理员进行网络故障排查、优化网络性能等工作。

## C++

### 聊一下C++的三大特性

三大特性：继承、封装和多态

**（1）继承**

**让某种类型对象获得另一个类型对象的属性和方法。**

它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展

常见的继承有三种方式：

1. 实现继承：指使用基类的属性和方法而无需额外编码的能力
2. 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
3. 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）

例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法

**（2）封装**

数据和代码捆绑在一起，避免外界干扰和不确定性访问。

封装，也就是**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。

**（3）多态**

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为**（重载实现编译时多态，虚函数实现运行时多态）**。

多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。**简单一句话：允许将子类类型的指针赋值给父类类型的指针**

实现多态有二种方式：覆盖（override），重载（overload）。

覆盖：是指子类重新定义父类的虚函数的做法。

重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。

### 聊一下new/delete 和 malloc/free，他们能否串用？

- malloc/free和new/delete都是用来申请内存和回收内存的。
- 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。
- 不能串用

### 聊一下C++的类型安全问题

C++的类型安全问题主要表现在以下几个方面：

1. 隐式类型转换：C++中存在各种隐式类型转换，如将整型赋值给浮点型变量、将指针类型转换为整型等。这些隐式类型转换可能会导致类型不匹配的问题，从而引发程序错误。

2. 指针类型安全：C++中指针类型的安全问题主要包括空指针、野指针、重复释放等。这些问题可能会导致程序崩溃或者内存泄漏。

3. 类型检查不严格：C++中的类型检查不如其他语言严格，例如可以将指向基类的指针转换为指向派生类的指针，但这可能会导致程序出现错误。

4. 强制类型转换：C++中的强制类型转换可能会破坏类型安全性，因为它允许程序员将不同类型的数据强制转换为目标类型，这可能会导致程序错误。

为了解决C++的类型安全问题，可以采取以下措施：

1. 尽量避免使用隐式类型转换，可以使用显式类型转换，或者使用static_cast、dynamic_cast等类型安全的转换方式。

2. 对指针类型进行严格的检查和管理，避免出现空指针、野指针、重复释放等问题。

3. 在进行类型转换时，要进行类型检查，确保类型转换的正确性。

4. 尽量避免使用强制类型转换，如果必须使用，要进行类型检查，确保转换的正确性。

### 聊一下C++内存模型

C++内存模型指的是程序在运行时如何使用计算机的内存资源。C++内存模型包括以下几个方面：

1. 内存区域：C++程序使用内存可以分为代码区、全局数据区、堆区和栈区。其中代码区用于存放程序的指令，全局数据区用于存放全局变量和静态变量，堆区用于存放动态分配的内存，栈区用于存放函数的局部变量和函数调用时的参数。

2. 内存分配和释放：C++中使用new和delete来进行动态内存的分配和释放，使用malloc和free也可以实现相同的功能。在使用动态内存时需要注意内存泄漏和指针悬挂的问题。

3. 内存访问：C++中可以通过指针来访问内存，使用指针时需要注意指针的合法性和指针指向的内存是否已经被释放。同时，C++中还有一些内存相关的关键字，如volatile和const，用于表示变量是否可以被修改。

4. 内存模型：C++中的内存模型指的是多线程并发访问内存时的行为规范。C++11引入了原子操作和线程库，使得多线程编程更加方便和安全。

总之，C++内存模型是C++程序员必须掌握的基本知识之一，对于保证程序的正确性和性能有着重要的作用。

### 聊一下C++中的智能指针

C++中的四大智能指针分别是unique_ptr、shared_ptr、weak_ptr和auto_ptr。

1. unique_ptr：独占式智能指针，用于管理动态分配的内存资源。它只能有一个指向同一个对象的指针，不能进行复制或赋值操作，但可以移动。当unique_ptr被销毁时，它所管理的对象也会被销毁。

2. shared_ptr：共享式智能指针，可以有多个指向同一个对象的指针。当所有shared_ptr都被销毁时，它所管理的对象才会被销毁。它使用引用计数的方式进行管理，每次有新的shared_ptr指向它所管理的对象时，引用计数加1，当有shared_ptr被销毁时，引用计数减1，当引用计数为0时，对象才会被销毁。

3. weak_ptr：弱引用智能指针，用于解决shared_ptr循环引用的问题。它可以指向由shared_ptr管理的对象，但不会增加引用计数，也不能直接访问所指向的对象，需要先将其转换为shared_ptr才能访问。当所有shared_ptr都被销毁时，weak_ptr也会被自动置空。

4. auto_ptr：已被C++11标准废弃，建议使用unique_ptr替代。它是一种独占式智能指针，但存在一些缺陷，比如不支持数组、存在悬空指针等问题。

### 聊一下define宏定义和const的区别

**编译阶段**

- define是在编译的**预处理**阶段起作用，而const是在编译、运行的时候起作用

**安全性**

- define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
- const常量有数据类型，编译器可以对其进行类型安全检查

**内存占用**

- define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
- 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
- 宏不检查类型；const会检查数据类型。
- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

### C++中有哪些种类的构造函数？

C++中的构造函数可以分为4类：

- 默认构造函数
- 初始化构造函数（有参数）
- 拷贝构造函数
- 移动构造函数（move和右值引用）
- 委托构造函数
- 转换构造函数

### 讲一下你对于网络中的大小端存储的了解（*）

大端存储：字数据的高字节存储在低地址中

小端存储：字数据的低字节存储在低地址中

例如：32bit的数字0x12345678

**所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输**